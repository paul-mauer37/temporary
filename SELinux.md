# SELinux





SELinux 이해를 위해 필수적인 접근 통제에 대해 알아보자.



**OS에서 접근통제(Access Control)**는 **디렉토리나 파일, 네트워크 소켓과 같은 시스템 자원**을 적절한 권한을 가진 **사용자나 그룹**이 접근하고 사용할 수 있도록 통제하는 것을 의미한다. 

* 시스템 자원 - 객체 (Object)

* 자원에 접근하는 사용자 혹은 프로세스 - 주체 (Subject)

```bash
# example)
/etc/passwd 파일 자체는 객체(Object)
암호변경 명령어 passwd는 주체(Subject)
```



이러한 접근 통제의 방법 중 대부분의 유닉스나 윈도우 등 운영체제에서 사용하는 모델이 임의 접근 통제(DAC; Discretionary Access Control)이다.

사용자나 그룹이 객체의 소유자라면 다른 주체에 대해 해당 객체에 대한 접근 권한을 설정할 수 있다. 임의적이라는 말은 소유자의 판단에 의해 권한을 줄 수 있다는 뜻이다. 사용이 간편하고 구현이 용이한 장점이 있지만, 만약 모든 권한을 가진 root 계정이 탈취당한다면 시스템이 장악될 수 있다는 위험도 존재한다.



유닉스 계열 OS에서는 실행 파일의 속성에 setuid(set user ID upon execution)또는 setgid(set group ID upon execution) 비트라는 것을 설정할 수 있다. 이 비트가 설정되어 있을 경우 해당 실행 파일을 실행할 때, 설정된 사용자(setuid) 또는 그룹(setgid) 권한으로 동작한다.

즉, passwd명령어와 ping명령어의 경우, 실행시 root 권한이 필요한데, 소유자를 root로 하고 setuid 비트를 설정하면 실행 시점에 root 사용자로 전환되게 된다. setuid, setgid 비트를 통해 root만 가능한 동작을 수행할 수 있게 된다.

```bash
$ ls -l /bin/ping /usr/bin/passwd
-rwxr-xr-x. 1 root root 40760  2월  20  2020 /bin/ping
-rwsr-xr-x. 1 root root 30768  2월  20  2020 /usr/bin/passwd
--- 사용자 퍼미션 부분의 's'표시는 setuid 비트
--- 그룹 퍼미션 부분의 's'표시는 setgid 비트

# setuid 비트가 설정된 프로그램 찾기
$ find /bin /usr/bin /sbin -perm -4000 -exec ls -ldb {} \;

# 비트가 설정된 프로그램을 이용하면 공격자는 손쉽게 root 권한을 획득할 수 있다.
```



---



well-known port(잘 알려진 포트)는 특정한 쓰임새를 위해 IANA에서 할당한 TCP 및 UDP 포트 번호의 일부로, 1024 미만의 포트 번호를 갖게 된다. 예를 들어, 웹에 사용되는 http(80), 메일 전송에 사용되는 smtp(25), 파일 전송에 사용되는 ftp(20, 21) 등이 well-known port입니다.

well-known port는 root만이 사용할 수 있으므로 서비스 데몬 역시 root 권한으로 기동된다. 여기서 서비스 데몬에 보안 취약점이 있거나 잘못된 설정이 있을 경우, 서비스 데몬을 통해 공격자는 root 권한을 획득하게 된다. 



---



강제 접근 통제(MAC; Mandatory Access Control)는 미리 정해진 정책과 보안 등급에 의거하여 주체에게 허용된 접근 권한과 객체에게 부여된 허용 등급을 비교하여 접근 통제하는 모델이다. 높은 보안을 요구하는 정보는 낮은 보안 수준의 주체가 접근할 수 없으며 소유자라고 할지라도 정책에 어긋나면 객체에 접근할 수 없으므로 강력한 보안을 제공한다.

MAC정책에서는 root로 구동한 http 서버라도 접근 가능한 파일과 포트가 제한된다. 다시 말해, 취약점을 이용해 httpd의 권한을 획득했어도 /var/www/html, /etc/httpd 등의 사전에 허용한 폴더에만 접근 가능하며 80, 443, 8080 등의 포트만 접근이 허용되므로, ssh로 다른 서버로 접근을 시도하는 등의 2차 피해가 최소화된다. 다만, 구현이 복잡하고 모든 주체와 객체에 대해 보안 등급과 허용 등급을 부여해야 하므로 설정이 복잡하고 시스템 관리자가 통제 모델에 대해 잘 이해하고 있어야 한다.



SELinux

SELinux는 기존 접근 통제 규칙보다 먼저 동작하므로 SELinux의 보안 정책에 맞지 않을 경우 차단해 버린다.

* 사전 정의된 접근 통제 정책 탑재

  사용자, 역할, 타입, 레벨 등의 다양한 정보를 조합하여 어떤 프로세스가 어떤 파일, 디렉토리, 포트 등에 접근 가능한지에 대해 사전에 잘 정의된 접근 통제 정책을 제공하기 때문에 MAC(강제 접근 통제) 적용을 위해 시스템 관리자가 할 일이 대폭 줄고 애플리케이션의 변경없이 setuid와 1024 이하 포트를 사용하는 데몬을 안전하게 사용할 수 있다.

* "Deny All, Permit Some"정책으로 잘못된 설정 최소화

  "모든 걸 차단하고 필요한 것만 허용"하는 정책으로 보안 정책이 사전에 설정되어 있으므로 잘못된 설정이 기본으로 포함돼있을 여지가 적다. 

* 권한 상승 공격에 의한 취약점 감소

  setuid비트 설정이나 root로 실행되는 프로세스처럼 위험한 프로그램들은 샌드박스 안에서 별도의 도메인으로 격리되어 실행되므로, root 권한을 탈취당해도 해당 도메인에만 영향을 미치고 전체 시스템에 미치는 영향은 최소화된다. 예를 들어, 아파치 httpd 서버의 보안 취약점을 통해 권한을 획득했어도 아파치같은 서버 데몬은 낮은 등급의 권한을 부여받으므로 공격자는 일반 사용자의 홈 디렉토리를 읽을 수 없고, /tmp 임시 디렉토리에 파일을 쓸 수 없다.

* 잘못된 설정과 버그로부터 시스템 보호

  잘못된 설정이나 신뢰할 수 없는 입력을 악용한 공격에서 프로세스를 보호할 수 있다. 예를 들어, 버퍼의 입력 길이 등을 제대로 체크하지 않아서 발생하는 buffer overflow attack(버퍼 오버 플로 공격)의 경우, SELinux가 애플리케이션 메모리에 있는 코드를 실행할 수 없게 통제하므로 데몬 프로그램에 buffer overflow 버그가 있어도 쉘을 얻을 수 없다.



---



SELinux는 커널의 기본 기능으로 동작하며, 모든 시스템 콜이 보안 정책을 확인해 접근 허용 여부를 판단하며 빠르게 처리하기 위해서 보안 정책은 AVC(Access Vector Cache)라는 이름으로 커널 내부에서 캐싱한다.











































